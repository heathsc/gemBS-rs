use std::path::PathBuf;

use clap::{crate_version, value_parser, Arg, ArgAction, ArgGroup, Command};
use clap_complete::Shell;

use crate::common::defs::*;
use crate::common::latex_utils::PageSize;
use utils::log_level::LogLevel;

pub(super) fn cli_model() -> Command {
    Command::new("gemBS").version(crate_version!())
        .author("Simon Heath <simon.heath@gmail.com>")
        .about("gemBS is a bioinformatics pipeline for analyzing whole genome bisulfite data (WGBS) data")
        .propagate_version(true)
        .subcommand_required(true)
        .arg_required_else_help(true)
        .arg(
            Arg::new("quiet")
                .short('q').long("quiet")
                .action(ArgAction::SetTrue)
                .help("Silence all output")
        )
        .arg(
            Arg::new("timestamp")
                .short('t').long("timestamp")
                .value_name("GRANULARITY")
                .value_parser(value_parser!(stderrlog::Timestamp))
                .default_value("none")
                .help("Prepend log entries with a timestamp")
        )
        .arg(
            Arg::new("loglevel")
                .short('l').long("loglevel")
                .value_name("LOGLEVEL")
                .value_parser(value_parser!(LogLevel))
                .default_value("warn")
                .help("Set log level")
        )
        .arg(
            Arg::new("config_file")
                .short('c').long("config-file")
                .value_parser(value_parser!(String))
                .value_name("CONFIG_FILE")
                .help("Location of gemBS config file")
        )
        .arg(
            Arg::new("dir")
                .short('d').long("dir")
                .value_name("DIR")
                .value_parser(value_parser!(PathBuf))
                .help("Set working directory")
        )
        .arg(
            Arg::new("gembs_root")
                .short('r').long("gembs-root")
                .value_parser(value_parser!(String))
                .value_name("CONFIG_FILE")
                .help("Set root directory of gemBS installation")
        )
        .arg(
            Arg::new("all")
                .short('a').long("all")
                .action(ArgAction::SetTrue)
                .help("Consider all tasks required for the requested command")
                .action(ArgAction::SetTrue)
        )
        .arg(
            Arg::new("dry_run")
                .action(ArgAction::SetTrue)
                .short('d').long("dry-run")
                .help("Output pending commands without execution")
        )
        .arg(
            Arg::new("json")
                .short('j').long("json")
                .value_parser(value_parser!(String))
                .value_name("FILE")
                .help("Output JSON file with details of pending commands")
        )
        .arg(
            Arg::new("ignore_times")
                .action(ArgAction::SetTrue)
                .short('i').long("ignore-times")
                .help("Ignore file modification times when evaluating the status of tasks")
        )
        .arg(
            Arg::new("ignore_status")
                .action(ArgAction::SetTrue)
                .short('I').long("ignore-status")
                .help("Ignore status of tasks when compiling task list")
        )
        .arg(
            Arg::new("keep_logs")
                .action(ArgAction::SetTrue)
                .short('k').long("keep-logs")
                .help("Don't remove log files after successful completion of task")
        )
        .subcommand(
            Command::new("prepare")
                .about("Prepare gemBS analysis")
                .arg(
                    Arg::new("config")
                        .short('c').long("config")
                        .value_name("FILE")
                        .required(true)
                        .value_parser(value_parser!(String))
                        .help("Text config file with gemBS parameters")
                )
                .arg(
                    Arg::new("cvs_metadata")
                        .short('t').long("text-metadata")
                        .value_name("FILE")
                        .value_parser(value_parser!(String))
                        .help("Sample metadata in csv format")
                )
                .arg(
                    Arg::new("json_metadata")
                        .short('l').long("json-metadata")
                        .value_name("FILE")
                        .value_parser(value_parser!(String))
                        .help("Sample metadata in JSON format")
                )
                .arg(
                    Arg::new("populate")
                        .short('p').long("populate-cache")
                        .action(ArgAction::SetTrue)
                        .help("Populate local reference cache if required (for CRAM)")
                )
                .group(
                    ArgGroup::new("metadata")
                        .args(&["cvs_metadata", "json_metadata"])
                        .required(true)
                )
        )
        .subcommand(
            Command::new("index")
                .about("Prepare genome indexes")
                .next_help_heading("index generation")
                .arg(
                    Arg::new("make_bs_index")
                        .short('b').long("bs-index")
                        .action(ArgAction::SetTrue)
                        .help("Generate bisulfite index")
                )
                .arg(
                    Arg::new("make_nonbs_index")
                        .short('n').long("nonbs-index")
                        .action(ArgAction::SetTrue)
                        .help("Generate non-bisulfite (regular) index")
                )
                .arg(
                    Arg::new("sampling")
                        .short('s').long("sampling-rate")
                        .hide(true)
                        .value_name("INT")
                        .help("Text sampling rate - increasing will decrease index size but also performance")
                )
                .next_help_heading("dbSNP index options")
                .arg(
                    Arg::new("make_dbsnp_index")
                        .short('D').long("dbsnp-index")
                        .action(ArgAction::SetTrue)
                        .help("Generate dbSNP index")
                )
                .arg(
                    Arg::new("min_contig_size")
                        .short('M').long("min-contig-size")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Contigs smaller than this will be filtered out during index generation")
                )
                .arg(
                    Arg::new("dbsnp_jobs")
                        .short('j').long("dbsnp-jobs")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of parallel read jobs for dbsnp_index")
                )
                .arg(
                    Arg::new("dbsnp_files")
                        .short('d').long("dbsnp-files")
                        .value_name("FILES")
                        .value_parser(value_parser!(String))
                        .help("List of input files for dbSNP")
                )
                .arg(
                    Arg::new("dbsnp_selected")
                        .short('S').long("dbsnp-selected")
                        .value_name("FILE")
                        .value_parser(value_parser!(String))
                        .help("File with list of selected SNPs from dbSNP")
                )
                .arg(
                    Arg::new("dbsnp_type")
                        .long("dbsnp-type")
                        .value_name("TYPE")
                        .value_parser(value_parser!(DbSnpFileType))
                        .default_value("auto")
                        .help("Type of dbSNP input files")
                )
                .arg(
                    Arg::new("dbsnp_chrom_alias")
                        .long("dbsnp-chrom-alias")
                        .value_name("FILE")
                        .value_parser(value_parser!(String))
                        .help("File with list of chromosome aliases")
                )
                .next_help_heading("process options")
                .arg(
                    Arg::new("threads")
                        .short('t').long("threads")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of threads [default: all available cores]")
                )
                .arg(
                    Arg::new("cores")
                        .short('c').long("cores")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of cores [default: all available cores]")
                )
                .arg(
                    Arg::new("memory")
                        .short('m').long("memory")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Memory required [default: all available memory]")
                )
                .arg(
                    Arg::new("time")
                        .short('T').long("time")
                        .value_parser(value_parser!(JobLen))
                        .value_name("TIME")
                        .help("Time required")
                )
        )
        .subcommand(
            Command::new("map")
                .about("Read Mapping")
                .next_help_heading("dataset selection")
                .arg(
                    Arg::new("dataset")
                        .short('D').long("dataset")
                        .value_name("STRING")
                        .value_parser(value_parser!(String))
                        .help("Dataset to be mapped")
                )
                .arg(
                    Arg::new("sample")
                        .short('n').long("sample")
                        .value_name("STRING")
                        .value_parser(value_parser!(String))
                        .help("Name of sample to be mapped")
                )
                .arg(
                    Arg::new("barcode")
                        .short('b').long("barcode")
                        .value_name("STRING")
                        .value_parser(value_parser!(String))
                        .help("Barcode of sample to be mapped")
                )
                .group(
                    ArgGroup::new("sample_desc")
                        .args(&["dataset", "sample", "barcode"])
                )
                .next_help_heading("global options")
                .arg(
                    Arg::new("threads")
                        .short('t').long("threads")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of threads for mapping pipeline [default: all available cores]")
                )
                .arg(
                    Arg::new("cores")
                        .short('c').long("cores")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of cores [default: all available cores]")
                )
                .arg(
                    Arg::new("memory")
                        .short('m').long("memory")
                        .value_name("MEMORY")
                        .value_parser(value_parser!(MemSize))
                        .help("Memory required [default: all available memory]")
                )
                .arg(
                    Arg::new("time")
                        .short('T').long("time")
                        .value_name("TIME")
                        .value_parser(value_parser!(JobLen))
                        .help("Time required")
                )
                .arg(
                    Arg::new("benchmark_mode")
                        .long("benchmark-mode")
                        .action(ArgAction::SetTrue)
                        .help("Omit dates etc. from output to make comparison simpler")
                )
                .next_help_heading("mapping options")
                .arg(
                    Arg::new("map_threads")
                        .long("map-threads")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of threads for GEM3 mapper [default: threads]")
                )
                .arg(
                    Arg::new("underconv_seq")
                        .short('u').long("underconversion-sequence")
                        .value_name("STRING")
                        .value_parser(value_parser!(String))
                        .help("Contig name of underconversion sequencing control")
                )
                .arg(
                    Arg::new("overconv_seq")
                        .short('u').long("overconversion-sequence")
                        .value_name("STRING")
                        .value_parser(value_parser!(String))
                        .help("Contig name of overconversion sequencing control")
                )
                .arg(
                    Arg::new("file_type")
                        .short('F').long("file-type")
                        .value_name("FILE_TYPE")
                        .value_parser(value_parser!(FileType))
                        .help("Type of data file(s)")
                )
                .arg(
                    Arg::new("paired")
                        .short('p').long("paired-end")
                        .action(ArgAction::SetTrue)
                        .help("Input data is paired end")
                )
                .arg(
                    Arg::new("reverse")
                        .short('R').long("reverse-conversion")
                        .action(ArgAction::SetTrue)
                        .help("Assume G2A conversion on read 1 and C2T on read 2")
                )
                .arg(
                    Arg::new("non_stranded")
                        .action(ArgAction::SetTrue)
                        .short('s').long("read-non-stranded")
                        .help("Treat library as non stranded")
                )
                .arg(
                    Arg::new("bs")
                        .action(ArgAction::SetTrue)
                        .long("bs")
                        .help("Map as bisulfite data")
                )
                .arg(
                    Arg::new("non_bs")
                        .action(ArgAction::SetTrue)
                        .long("non-bs")
                        .help("Map as regular (non-bisulfite) data")
                )
                .group(
                    ArgGroup::new("mapping_types")
                        .args(&["bs", "non_bs"])
                )
                .next_help_heading("sorting options")
                .arg(
                    Arg::new("sort_threads")
                        .long("sort-threads")
                        .value_parser(value_parser!(isize))
                        .value_name("INT")
                        .help("Number of threads for sorting [default: threads]")
                )
                .arg(
                    Arg::new("sort_memory")
                        .long("sort-memory")
                        .value_parser(value_parser!(MemSize))
                        .value_name("MEMORY")
                        .help("Memory allocated per sort threads")
                )
                .arg(
                    Arg::new("tmp_dir")
                        .short('d').long("tmp-dir")
                        .value_name("PATH")
                        .value_parser(value_parser!(String))
                        .help("Directory for temporary files (for sorting)")
                )
                .next_help_heading("merge options")
                .arg(
                    Arg::new("merge_threads")
                        .long("merge-threads")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of threads for merging [default: threads]")
                )
                .arg(
                    Arg::new("merge")
                        .action(ArgAction::SetTrue)
                        .long("merge")
                        .help("Perform merge BAM step only")
                )
                .arg(
                    Arg::new("no_merge")
                        .action(ArgAction::SetTrue)
                        .long("no-merge")
                        .help("Do not automatically merge BAMs")
                )
                .arg(
                    Arg::new("md5")
                        .action(ArgAction::SetTrue)
                        .long("md5")
                        .help("Perform calculation of md5 sums only")
                )
                .arg(
                    Arg::new("no_md5")
                        .action(ArgAction::SetTrue)
                        .long("no-md5")
                        .help("Do not automatically calculate md5 sums")
                )
                .arg(
                    Arg::new("remove")
                        .action(ArgAction::SetTrue)
                        .short('r').long("remove")
                        .help("Remove individual BAMs after merging")
                )
                .group(
                    ArgGroup::new("remove_group")
                        .args(&["remove", "no_merge"])
                )
                .group(
                    ArgGroup::new("merging")
                        .args(&["merge", "no_merge"])
                )
                .group(
                    ArgGroup::new("md5_group")
                        .args(&["md5", "no_md5"])
                )
        )
        .subcommand(
            Command::new("call")
                .about("Methylation and SNP calling")
                .next_help_heading("sample / contig selection")
                .arg(
                    Arg::new("sample")
                        .value_parser(value_parser!(String))
                        .short('n').long("sample")
                        .value_name("STRING")
                        .help("Name of sample to be processed")
                )
                .arg(
                    Arg::new("barcode")
                        .value_parser(value_parser!(String))
                        .short('b').long("barcode")
                        .value_name("STRING")
                        .help("Barcode of sample to be processed")
                )
                .arg(
                    Arg::new("pool")
                        .value_parser(value_parser!(String))
                        .long("pool")
                        .value_name("STRING")
                        .action(clap::ArgAction::Append)
                        .help("Contig pool to be processed")
                )
                .group(
                    ArgGroup::new("sample_desc")
                        .args(&["sample", "barcode"])
                )
                .next_help_heading("filtering")
                .arg(
                    Arg::new("mapq_threshold")
                        .value_parser(value_parser!(isize))
                        .short('q').long("mapq-threshold")
                        .value_name("INT")
                        .help("Minimum threshold for MAPQ scores")
                )
                .arg(
                    Arg::new("qual_threshold")
                        .value_parser(value_parser!(isize))
                        .short('q').long("qual-threshold")
                        .value_name("INT")
                        .help("Minimum threshold for base quality scores")
                )
                .arg(
                    Arg::new("max_template_length")
                        .value_parser(value_parser!(isize))
                        .short('L').long("max-template-length")
                        .value_name("INT")
                        .help("Maximum threshold for template length of paired reads")
                )
                .arg(
                    Arg::new("right_trim")
                        .value_parser(value_parser!(isize))
                        .short('g').long("right-trim")
                        .value_name("INT [,INT]")
                        .num_args(1..=2)
                        .help("Bases to trim from right of read pair (give 2 values for read specific values)")
                )
                .arg(
                    Arg::new("left_trim")
                        .value_parser(value_parser!(isize))
                        .short('f').long("left-trim")
                        .value_name("INT [,INT]")
                        .num_args(1..=2)
                        .help("Bases to trim from left of read pair (give 2 values for read specific values)")
                )
                .arg(
                    Arg::new("keep_duplicates")
                        .action(ArgAction::SetTrue)
                        .short('u').long("keep-duplicates")
                        .help("Do not merge duplicate reads")
                )
                .arg(
                    Arg::new("ignore_duplicate_flag")
                        .action(ArgAction::SetTrue)
                        .short('U').long("ignore-duplicate-flag")
                        .help("Ignore duplicate flag from input SAM/BAM/CRAM file")
                )
                .arg(
                    Arg::new("keep_unmatched")
                        .action(ArgAction::SetTrue)
                        .short('k').long("keep-unmatched")
                        .help("Do not discard reads that do not form proper pairs")
                )
                .next_help_heading("process options")
                .arg(
                    Arg::new("jobs")
                        .short('j').long("jobs")
                        .value_parser(value_parser!(isize))
                        .value_name("INT")
                        .help("Number of parallel jobs")
                )
                .arg(
                    Arg::new("threads")
                        .value_parser(value_parser!(isize))
                        .short('t').long("threads")
                        .value_name("INT")
                        .help("Number of threads for calling pipeline")
                )
                .arg(
                    Arg::new("call_threads")
                        .value_parser(value_parser!(isize))
                        .long("threads")
                        .value_name("INT")
                        .help("Number of threads for methylation caller")
                )
                .arg(
                    Arg::new("merge_threads")
                        .value_parser(value_parser!(isize))
                        .long("merge-threads")
                        .value_name("INT")
                        .help("Number of threads for BCF merging step")
                )
                .arg(
                    Arg::new("cores")
                        .value_parser(value_parser!(isize))
                        .short('c').long("cores")
                        .value_name("INT")
                        .help("Number of cores for a job [default: available cores / jobs]")
                )
                .arg(
                    Arg::new("memory")
                        .value_parser(value_parser!(MemSize))
                        .short('m').long("memory")
                        .value_name("MEMORY")
                        .help("Memory required for a job [default: available memory / jobs]")
                )
                .arg(
                    Arg::new("time")
                        .value_parser(value_parser!(JobLen))
                        .short('T').long("time")
                        .value_name("TIME")
                        .help("Time required for a job")
                )
                .next_help_heading("calling options")
                .arg(
                    Arg::new("haploid")
                        .action(ArgAction::SetTrue)
                        .short('1').long("haploid")
                        .help("Force genotype calls to be haploid")
                )
                .arg(
                    Arg::new("conversion")
                        .short('C').long("conversion")
                        .value_names(&["[UNDER]", "OVER"])
                        .value_parser(value_parser!(f64))
                        .num_args(1..=2).value_delimiter(' ')
                        .help("Set conversion rates (under over)")
                )
                .arg(
                    Arg::new("auto_conversion")
                        .action(ArgAction::SetTrue)
                        .long("auto-conversion")
                        .help("Estimate conversion rates from mapping data")
                )
                .group(
                    ArgGroup::new("conversion_group")
                        .args(&["conversion", "auto_conversion"])
                )
                .arg(
                    Arg::new("ref_bias")
                        .short('R').long("reference-bias")
                        .value_parser(value_parser!(f64))
                        .value_name("FLOAT")
                        .help("Set bias (weight) for reference homozygote")
                )
                .arg(
                    Arg::new("dbsnp_index")
                        .short('D').long("dbsnp-index")
                        .value_name("PATH")
                        .value_parser(value_parser!(String))
                        .help("Path to dbSNP_idx processed SNP database file")
                )
                .next_help_heading("general options")
                .arg(
                    Arg::new("md5")
                        .action(ArgAction::SetTrue)
                        .long("md5")
                        .help("Perform calculation of md5 sums only")
                )
                .arg(
                    Arg::new("no_md5")
                        .action(ArgAction::SetTrue)
                        .long("no-md5")
                        .help("Do not automatically calculate md5 sums")
                )
                .group(
                    ArgGroup::new("md5_group")
                        .args(&["md5", "no_md5"])
                )
                .arg(
                    Arg::new("index")
                        .action(ArgAction::SetTrue)
                        .long("index")
                        .help("Perform indexing of final BCF only")
                )
                .arg(
                    Arg::new("no_index")
                        .action(ArgAction::SetTrue)
                        .long("no-index")
                        .help("Do not automatically calculate index final BCF")
                )
                .group(
                    ArgGroup::new("index_group")
                        .args(&["index", "no_index"])
                )
                .arg(
                    Arg::new("remove")
                        .action(ArgAction::SetTrue)
                        .short('r').long("remove")
                        .help("Remove individual BCFs after merging")
                )
                .group(
                    ArgGroup::new("remove_group")
                        .args(&["remove", "no_merge"])
                )
                .arg(
                    Arg::new("merge")
                        .action(ArgAction::SetTrue)
                        .long("merge")
                        .help("Perform merge BCF step only")
                )
                .arg(
                    Arg::new("no_merge")
                        .action(ArgAction::SetTrue)
                        .long("no-merge")
                        .help("Do not automatically merge BCFs")
                )
                .group(
                    ArgGroup::new("merge_group")
                        .args(&["merge", "no_merge"])
                )
                .arg(
                    Arg::new("species")
                        .short('e').long("species")
                        .value_parser(value_parser!(String))
                        .value_name("STRING")
                        .help("Species name")
                )
                .arg(
                    Arg::new("benchmark_mode")
                        .action(ArgAction::SetTrue)
                        .long("benchmark-mode")
                        .help("Omit dates etc. from output to make comparison simpler")
                )
        )
        .subcommand(
            Command::new("extract")
                .about("Produce methylation and SNP summary files")
                .next_help_heading("sample / contig selection")
                .arg(
                    Arg::new("sample")
                        .short('n').long("sample")
                        .value_parser(value_parser!(String))
                        .value_name("STRING")
                        .help("Name of sample to be processed")
                )
                .arg(
                    Arg::new("barcode")
                        .value_parser(value_parser!(String))
                        .short('b').long("barcode")
                        .value_name("STRING")
                        .help("Barcode of sample to be processed")
                )
                .group(
                    ArgGroup::new("sample_desc")
                        .args(&["sample", "barcode"])
                )
                .next_help_heading("filtering")
                .arg(
                    Arg::new("qual_threshold")
                        .value_parser(value_parser!(isize))
                        .short('Q').long("qual-threshold")
                        .value_name("INT")
                        .help("Minimum threshold for base quality scores")
                )
                .arg(
                    Arg::new("phred_threshold")
                        .value_parser(value_parser!(isize))
                        .short('q').long("phred-threshold")
                        .value_name("INT")
                        .help("Minimum threshold for genotype PHRED score (gemBS bed)")
                )
                .arg(
                    Arg::new("min_inform")
                        .value_parser(value_parser!(isize))
                        .short('I').long("min-inform")
                        .value_name("INT")
                        .help("Minimum threshold for informative reads (gemBS bed)")
                )
                .arg(
                    Arg::new("min_nc")
                        .value_parser(value_parser!(isize))
                        .short('I').long("min-nc")
                        .value_name("INT")
                        .help("Minimum threshold for non-converted reads for non-CpG sites (gemBS bed)")
                )
                .arg(
                    Arg::new("allow_het")
                        .action(ArgAction::SetTrue)
                        .short('H').long("allow-het")
                        .value_name("INT")
                        .help("Allow both homozygous and heterozygous sites (gemBS bed)")
                )
                .arg(
                    Arg::new("ref_bias")
                        .value_parser(value_parser!(f64))
                        .short('R').long("reference-bias")
                        .value_name("FLOAT")
                        .help("Set bias (weight) for reference homozygote")
                )
                .next_help_heading("output options")
                .arg(
                    Arg::new("cpg")
                        .action(ArgAction::SetTrue)
                        .short('C').long("cpg")
                        .help("Output gemBS bed with filtered CpG sites")
                )
                .arg(
                    Arg::new("non_cpg")
                        .action(ArgAction::SetTrue)
                        .short('N').long("non-cpg")
                        .help("Output gemBS bed with filtered non-CpG sites")
                )
                .arg(
                    Arg::new("strand_specific")
                        .action(ArgAction::SetTrue)
                        .short('s').long("strand-specific")
                        .help("Output separate lines in CpG file for each strand (gemBS bed)")
                )
                .arg(
                    Arg::new("bed_methyl")
                        .action(ArgAction::SetTrue)
                        .short('B').long("bedmethyl").alias("bed-methyl")
                        .help("Output ENCODE standard output (bedMethyl, bigBed and bigWig)")
                )
                .arg(
                    Arg::new("bigwig_strand_specific")
                        .action(ArgAction::SetTrue)
                        .short('W').long("bigwig-strand-specific")
                        .help("Output separate bigWig files for each strand (bedMethyl output)")
                )
                .arg(
                    Arg::new("snps")
                        .action(ArgAction::SetTrue)
                        .short('S').long("snps")
                        .help("Output snps")
                )
                .arg(
                    Arg::new("snp_list")
                        .value_parser(value_parser!(String))
                        .long("snp-list")
                        .value_name("PATH")
                        .help("Path to file with list of SNPs to output")
                )
                .arg(
                    Arg::new("snp_db")
                        .value_parser(value_parser!(String))
                        .long("snp-db")
                        .value_name("PATH")
                        .help("Path to dbSNP_idx processed SNP database file")
                )
                .arg(
                    Arg::new("no_md5")
                        .action(ArgAction::SetTrue)
                        .long("no-md5")
                        .help("Do not automatically calculate md5 sums")
                )
                .next_help_heading("process options")
                .arg(
                    Arg::new("jobs")
                        .short('j').long("jobs")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of parallel jobs")
                )
                .arg(
                    Arg::new("threads")
                        .short('t').long("threads")
                        .value_name("INT")
                        .value_parser(value_parser!(isize))
                        .help("Number of threads for extraction pipeline")
                )
                .arg(
                    Arg::new("cores")
                        .short('c').long("cores")
                        .value_parser(value_parser!(isize))
                        .value_name("INT")
                        .help("Number of cores for a job [default: available cores / jobs]")
                )
                .arg(
                    Arg::new("memory")
                        .short('m').long("memory")
                        .value_name("MEMORY")
                        .value_parser(value_parser!(MemSize))
                        .help("Memory required for a job [default: available memory / jobs]")
                )
                .arg(
                    Arg::new("time")
                        .short('T').long("time")
                        .value_name("TIME")
                        .value_parser(value_parser!(JobLen))
                        .help("Time required for a job")
                )
        )
        .subcommand(
            Command::new("report")
                .about("Generate QC reports")
                .arg(
                    Arg::new("project")
                        .short('p').long("project")
                        .value_parser(value_parser!(String))
                        .value_name("STRING")
                        .help("Output title for report (project name)")
                )
                .arg(
                    Arg::new("report_dir")
                        .value_parser(value_parser!(String))
                        .short('r').long("report-dir")
                        .value_name("PATH")
                        .default_value("gemBS_reports")
                        .help("Root directory for reports")
                )
                .arg(
                    Arg::new("paper_size")
                        .value_parser(value_parser!(PageSize))
                        .short('S').long("paper-size")
                        .value_name("PAPER_SIZE")
                        .ignore_case(true)
                        .help("Select paper size of latex version of report")
                )
                .arg(
                    Arg::new("mapping")
                        .action(ArgAction::SetTrue)
                        .short('M').long("mapping")
                        .help("Generate the mapping report only")
                )
                .arg(
                    Arg::new("calling")
                        .action(ArgAction::SetTrue)
                        .short('C').long("calling")
                        .help("Generate the calling report only")
                )
                .arg(
                    Arg::new("pdf")
                        .action(ArgAction::SetTrue)
                        .short('P').long("pdf")
                        .help("Generate pdf version of report (requires latexmk and pdflatex)")
                )
                .arg(
                    Arg::new("threads")
                        .value_parser(value_parser!(isize))
                        .short('t').long("threads")
                        .value_name("INT")
                        .help("Number of threads for report generation")
                )
                .arg(
                    Arg::new("cores")
                        .value_parser(value_parser!(isize))
                        .short('c').long("cores")
                        .value_name("INT")
                        .help("Number of cores")
                )
                .arg(
                    Arg::new("memory")
                        .value_parser(value_parser!(MemSize))
                        .short('m').long("memory")
                        .value_name("MEMORY")
                        .help("Memory required")
                )
                .arg(
                    Arg::new("time")
                        .value_parser(value_parser!(JobLen))
                        .short('T').long("time")
                        .value_name("TIME")
                        .help("Time required")
                )

        )
        .subcommand(
            Command::new("run")
                .about("Run all pending pipeline commands")
        )
        .subcommand(
            Command::new("completions")
                .about("Generate shell completion files")
                .arg(
                    Arg::new("shell")
                        .short('s').long("shell")
                        .value_name("SHELL")
                        .value_parser(value_parser!(Shell))
                        .default_value("bash")
                        .help("Destination shell for completion file")
                )
                .arg(
                    Arg::new("output")
                        .short('o').long("output")
                        .value_name("PATH")
                        .value_parser(value_parser!(String))
                        .default_value("gemBS")
                        .help("Output file")
                )

        )
        .subcommand(
            Command::new("clear")
                .about("Clear up incomplete files after aborted run")
                .arg(
                    Arg::new("confirm")
                        .action(ArgAction::SetTrue)
                        .short('y').long("yes")
                        .help("Do not ask for confirmation")
                )
                .arg(
                    Arg::new("force")
                        .action(ArgAction::SetTrue)
                        .short('f').long("force")
                        .help("Continue even if lock file found")
                )
        )
}
